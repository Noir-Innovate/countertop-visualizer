import { createClient } from "@/lib/supabase/client";

export interface Slab {
  id: string;
  name: string;
  imageUrl: string;
  description: string;
}

// Helper to generate slab ID from filename
function generateSlabId(filename: string): string {
  return filename
    .replace(/\.[^.]+$/, "") // Remove extension
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-") // Replace non-alphanumeric with dashes
    .replace(/^-+|-+$/g, ""); // Trim dashes
}

// Helper to generate slab name from filename
function generateSlabName(filename: string): string {
  return filename
    .replace(/\.[^.]+$/, "") // Remove extension
    .replace(/[-_]/g, " ") // Replace dashes/underscores with spaces
    .replace(/\b\w/g, (c) => c.toUpperCase()); // Capitalize words
}

// Fetch slabs dynamically from a material line's Supabase storage folder
export async function getSlabsForMaterialLine(
  supabaseFolder: string
): Promise<Slab[]> {
  const supabase = createClient();
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;

  // First, get the material_line_id from the supabase_folder
  const { data: materialLine } = await supabase
    .from("material_lines")
    .select("id")
    .eq("supabase_folder", supabaseFolder)
    .single();

  const materialLineId = materialLine?.id;

  // List files from the material line's folder in public-assets bucket
  const { data: files, error } = await supabase.storage
    .from("public-assets")
    .list(supabaseFolder);

  if (error) {
    console.error("Error fetching slabs:", error);
    return [];
  }

  // If we have a material_line_id, fetch material metadata from database
  let materialsMap: Map<string, { title: string | null; description: string | null }> = new Map();
  
  if (materialLineId) {
    const { data: materials } = await supabase
      .from("materials")
      .select("filename, title, description")
      .eq("material_line_id", materialLineId);

    if (materials) {
      materials.forEach((m) => {
        materialsMap.set(m.filename, {
          title: m.title,
          description: m.description,
        });
      });
    }
  }

  // Filter for image files and map to Slab objects
  const slabs: Slab[] = (files || [])
    .filter((file) => file.name.match(/\.(jpg|jpeg|png|webp|gif|tif|tiff)$/i))
    .map((file) => {
      const materialMeta = materialsMap.get(file.name);
      const autoGeneratedName = generateSlabName(file.name);
      const autoGeneratedDescription = `${autoGeneratedName} quartz countertop material`;

      return {
        id: generateSlabId(file.name),
        name: materialMeta?.title || autoGeneratedName,
        imageUrl: `${supabaseUrl}/storage/v1/object/public/public-assets/${supabaseFolder}/${file.name}`,
        description: materialMeta?.description || autoGeneratedDescription,
      };
    });

  return slabs;
}

// Get featured slabs (first 3 slabs by default)
export function getFeaturedSlabs(slabs: Slab[], count: number = 3): string[] {
  return slabs.slice(0, count).map((s) => s.id);
}

// Legacy function for backwards compatibility - uses default folder
export async function getDefaultSlabs(): Promise<Slab[]> {
  return getSlabsForMaterialLine("accent-countertops");
}
